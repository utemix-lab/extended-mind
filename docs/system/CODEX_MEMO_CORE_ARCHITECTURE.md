# Временная памятка Codex — архитектура и интерфейсные правила (не инструкция)

Ниже — сводка того, что уже построено, какие сущности есть/нет, как работают режимы, как это проявляется в UI, какие правила держат порядок, и как тестировать механику без RAG/LLM. Это не канон и не системный документ, а временная памятка для сверки с замыслом и возвращения к общей картине.

## 0) Большая картина в 3 слоях

### Слой 1 — Canon (минимальная онтология)
- Граф узлов `universe.json`: `system`, `characters`, `domains`, `practices` (и узлы-опоры).
- Немного ребер (`relates` / `contains` / др.).
- Короткие тексты 3S (или ссылки).

**Canon отвечает на вопрос:**  
«Что в системе считается устойчивым и достойным быть узлом?»

Canon не описывает мир. Он описывает систему, её континенты, способы движения и проводников.

### Слой 2 — Catalogs (масса мира, строки)
- JSONL: каждая строка — объект мира (сервис, модель, метод, VST, фестиваль, студия и т.п.).
- **Catalog items — это строки, а не узлы.**

**Catalog отвечает на вопрос:**  
«Как быстро увидеть множество объектов по контексту, не раздувая граф?»

### Слой 3 — UI Reactions (режимы как реакции)
Это не слой данных, а логика интерфейса:
- пользователь кликает на что-то;
- система выбирает тип ответа;
- Service‑панель показывает нужную форму (выдача/действия/шаги/сигналы).

**UI reactions отвечают на вопрос:**  
«Как пользователь получает пользу без тысячи узлов?»

## 1) Что такое “режим”

**Ключевая формула:**  
Режим — не сущность. Режим — форма ответа интерфейса на событие.

Режим выбирается не переключателем, а **последним осмысленным действием** пользователя.

Нет “страницы Query”. Есть **Query‑ответ**, потому что кликнули на маркер контекста.

## 2) Сущности и несущности

### 2.1 Сущности (Entities) — только то, что достойно узла
Node (canon):
- `domain` (континенты)
- `character` (проводники)
- `practice` (опорный язык движения)
- `system` узлы: modules/specs/policies/processes (если нужно для самоописания)

**Node = точка навигации и смысловой якорь.**

### 2.2 Несущности (Context Keys / Projections)
Это то, что выглядит как теги, но формализовано как projection prefixes:
- `cap:` — возможность/функция мира (`lipsync`, `image_to_image`, `vst-synth`)
- `provider:` — провайдер/платформа (`adobe`, `krea`)
- `country:` — контекст страны
- `domain:` — контекст континента (может участвовать в каталогах)

Важно: **projection prefix ≠ сущность.**  
Это ключ фильтра/контекста, не объект мира.

### 2.3 Catalog items (Rows)
Пример: `service:krea`, `model:sdxl`, `method:controlnet`.
Это не узлы, но это **выдаваемые элементы** в Query Mode.

## 3) Что здесь “нового”

Это не “научная новизна”, а архитектурная дисциплина:
- Canon остаётся маленьким (карта, не территория).
- Мир приходит строками (каталоги).
- Навигация по миру идёт через контекстные ключи (projections).
- UI read-only (рендеры не редактируют истину).
- Авторитет/курация персонажей накладывается поверх (signals/curated_sets), не превращается в онтологию.

**Стиль:** Graph-native system design  
Минимальный канон + каталоги + контекстная навигация.

## 4) Query Mode функционально

### 4.1 Query Mode = реакция на контекст
Query Mode появляется, когда пользователь кликает на маркер:
«Покажи мне всё релевантное по этому контексту».

Маркер может быть:
- projection в тексте (`cap:lipsync`)
- виджет‑флаг (например `country:jp`)
- кнопка “Explore” или пресет
- pointer tags в карточках выдачи

### 4.2 Query Mode делает три вещи
1) Нормализует ключ (`normalizeTag`).
2) Резолвит внешний запрос (`resolveQuery`):
   - если есть `external_queries` → ссылки;
   - иначе fallback (`tagToFallbackQuery`).
3) Фильтрует каталоги по `pointer_tags`:
   - группирует (Services / Models / Methods / Other);
   - показывает карточки.

### 4.3 Важно
Query Mode:
- не строит новую структуру;
- не создаёт узлы;
- не пишет в canon.

Это просто: **контекст → выдача**.

## 5) Полнота мира и внешняя навигация

Если цель — “находить любой объект мира”, то:
- либо нужен полный внутренний каталог;
- либо нужна внешняя навигация (HF, LastFM и т.п.).

Текущая цель:
- быстро ориентироваться;
- давать авторские маршруты и подборки;
- сцеплять “что услышал” → “где это в системе”;
- не взрывать canon.

Следствие:
- база может быть неполной;
- важное (через персонажей) — отражено;
- полное — доступно внешними ссылками.

## 6) Как это должно проявляться в UI

Чтобы “видеть работу системы”, интерфейс должен явно показывать:

1) **Navigation state**  
Клик по узлу → выбранный узел → 3S/refs.

2) **Context stack state**  
Появляются pills (`cap:...`, `country:...`, `provider:...`), есть кнопка ✕ снять контекст.

3) **Response type state**  
Service‑панель визуально показывает тип ответа:
`Results` / `Actions` / `Steps` / `Signals`.

Важно: не текстом “режим Query”, а **формой**.

## 7) Где должны “появляться” маркеры

### 7.1 Узлы (canon)
Клик по узлу → Story/System/Service наполняются.

### 7.2 Контекстные маркеры (projections)
Появляются из:
- текста узла (например `cap:lipsync`);
- виджетов/флагов;
- карточек выдачи (pointer_tags).

Любой маркер вызывает Query Mode.

### 7.3 Practices (узлы)
Практик должно быть немного:
- это опорный язык движения;
- не тысячи, а 10–50.

Мелкие действия живут как:
- `cap:` / `method:` и т.п. (контекст),
- или UI‑действия.

## 8) Минимальный тест без RAG

Сценарий “узел → маркер → выдача”:
- В `character-vova` добавить `cap:vst-synth` как маркер.
- В `ai_catalog.jsonl` добавить 10 строк с `pointer_tags` `cap:vst-synth`.
- В Visitor клик по `cap:vst-synth` → Service показывает выдачу.
- Если есть `external_queries` → ссылка наружу.

Если это работает — канон не растёт, мир подцеплен, маркер вызывает реакцию.

## 9) Guardrails (минимальные правила порядка)

- Catalog row ≠ Node  
- Projection prefix ≠ entity  
- Query Mode ≠ navigation  
- UI read-only (рендеры не пишут в canon)  
- Canon хранит якоря, не справочники  
- Публичные списки всегда Top‑N/curated, никогда “всё на свете”

Технически:
- `assets.manifest.json` — индекс exports
- `loadExports()` грузит catalogs/registries
- `resolveQuery()` готовит внешние ссылки
- `activeContextStack[]` — UI‑state (не canon)

## 10) Самое полезное UI‑улучшение сейчас

Чтобы архитектура стала “видимой”:
- **Context strip** (ряд pills) — всегда видимый.
  - каждая pill показывает тип: projection/entity;
  - источник: clicked in Story / clicked in card / clicked in widget;
  - кнопка ✕.
- Service‑панель показывает **Response type**.

Это не новый функционал, а индикаторы уже существующей механики.

---

## Напоминание о замысле: “Vova → VST demo seed”

Это не инструкция, а ориентир для понимания механики “узел → маркер → Query Mode → выдача”.

### Контекст
- Query Mode работает, но ощущение “механики” теряется, потому что:
  - в canon/узлах мало реальных маркеров (`cap:` / `provider:`),
  - нет VST‑каталога (паттерн отработан только на AI),
  - нет демонстрационного пути “Вова → Query Mode”.

### Цель (1 тестовый сценарий)
Сделать демо “VSTablishment” для Вовы:
- В Story Вовы есть маркеры `cap:*` и `provider:*` (минимум 2–3).
- В exports есть `vst_catalog.jsonl` (10–20 строк).
- Клик по маркеру активирует Query Mode:
  - Service показывает выдачу (группы “Plugins/Other” или “Services/Other”).
  - Появляется “Open external search” (если есть `external_queries`).
- Никаких узлов для VST/производителей/плагинов в `universe.json` не создаём.

### Что НЕ делаем
- Нет полноценного VST‑парсера/агрегатора.
- Нет онтологии производителей/плагинов (узлов).
- Нет сложных AND/OR фильтров, facet‑ocean, многослойных видов.
- Нет “Try query” — Query Mode просто реагирует.
- Нет новых UI‑режимов и переразметки 3S окон.

### План (ориентир)
1) Добавить VST‑каталог:
   - `contracts/public/exports/vst_catalog.jsonl` (10–20 строк).
   - Строка: `id`, `kind`, `title`, `pointer_tags`, опционально `external_refs`.
   - Минимальные теги: `domain:music`, `cap:vst-*`, `provider:*`.
2) Обновить manifest exports:
   - `contracts/public/manifests/assets.manifest.json` → добавить `vst_catalog.jsonl`.
3) Добавить минимальные VST‑теги в registry:
   - `contracts/public/exports/pointer_tags_registry.json`.
   - 2–3 тега с `external_queries`.
4) Встроить маркеры в узел Вовы:
   - `contracts/public/graph/universe.json`.
   - В Story/Service добавить `cap:vst-synth`, `cap:vst-sampler`, `provider:native-instruments`.
5) Убедиться, что loader грузит VST‑каталог:
   - `dream-graph/src/scenes/visitor.js` читает catalogs из manifest и ищет по всем.
6) Минимальная группировка выдачи:
   - Service: секции “Plugins” (kind=plugin) и “Other”.
7) Синк snapshot:
   - `dream-graph/public/contracts/public` обновлён.

### Acceptance criteria (минимум)
- Вова → кликабельные маркеры (`cap:vst-synth`, `cap:vst-sampler`, `provider:native-instruments`).
- Клик по маркеру → Query Mode → выдача из `vst_catalog.jsonl`.
- Есть “Open external search” (если есть `external_queries`).
- Никаких новых узлов для плагинов/производителей в canon.

### Небольшая фиксация в docs (когда будет нужно)
- `extended-mind/docs/specs/POINTER_TAGS_AND_QUERY_MODE.md`:
  - “Vova → VST” как эталонный сценарий.
  - “catalog items are rows”.
  - “canon has only marker entry points”.

---

## Связанные документы
- `extended-mind/docs/system/SYSTEM_LANGUAGE_ACTORS_INSTRUMENTS_MATTER.md` — язык ролей сцены
- `contracts/contracts/public/ui/SCENOGRAPHY_RULES.md` — правила сценографии UI

